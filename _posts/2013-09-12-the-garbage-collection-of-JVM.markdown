---
layout: post
title: JAVA 虚拟机垃圾回收机制
date: 2013-09-12 20:01
author: "ethansure"
header-img: "img/post-bg-01.jpg"
---

在介绍Java虚拟机垃圾回收机制之前，先看一个其他系统的回收机制：

引用计数

原理：

每个对象有一个引用计数器，当有引用连接到对象时，引用计数加1，当引用离开作用域或被置为NULL时，引用计数减1。
垃圾回收器会在含有全部对象的上遍历，当发现某个对象的引用计数为0是，就释放其空间，事实上，引用技术模式经常会在计数值变为0时立即释放对象）。
缺点：

速度慢
虽管理引用的开销不大，但是这项开销在整个程序生命周期中将持续发生。
若对象之间存在循环引用，可能会出现“对象应该被回收，但引用计数不为零”的情况。 所以该回收方法未应用于任何一种JAVA虚拟机实现中
活对象追踪

原理：

任何一个“活”的对象，一定能追溯到其存活在堆栈或者静态储存区之中的引用。所以从堆栈和静态存储区开始，遍历所有的引用，就能找到这些"活"的对象

应用:

Java虚拟机在这种方式下采用自适应的垃圾回收技术。 有一种处理存活对象的方法叫停止-复制:先暂停程序的运行，将所有存活的对象从当前堆复制到另一个堆，没有被复制的都是垃圾，复制到新堆是紧挨排列的。

缺点：

需要两个堆，维护空间多了一倍
在产生少量垃圾的情况下，采用这种方式进行垃圾回收十分浪费（所以采取自适应）
自适应的方式:

“标记-清洁"，用上诉方法标记所有活对象，清理没有标记的对象。这种方法在少量垃圾产生的情况下速度快，但一般情况下很慢。这种模式会产生碎片空间。

注:停止-复制、标记-清洁都要求程序暂停

综上，目前Java虚拟机中，内存分配以较大的“块”为单位，在“停止-复制”中，不对存活的大型对象进行复制清理，会对内含小对象的块进行复制清理，并且可将其复制到废弃的块里，减少了部分大量内存复制的行为。

附：java虚拟机使用JIT(Just-In-Time) 编译技术来提升其速度.
