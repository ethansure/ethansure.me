---
layout: post
title: 数据转换也会出大问题
date: 2013-09-4 21:40:02
author: "ethansure"
header-img: "img/post-bg-01.jpg"
---


#迷惑  

```java
	public class Multicast {
		public static void main(String[] args){
			System.out.println(2.00-1.10);
		}
	}    
```

如果你很傻很天真的认为系统会打印"0.9"，那你就面壁去吧。结果是0.8999999999999999。在此推荐JAVA解惑这本书，非常有趣，虽然实用价值毕竟比不上什么实战书籍，但是我感觉书给我带来的求知欲和乐趣是巨大的,这玩意就是我从上面拿下来的，但是我个人认为书中并没有讲得很清楚，或者是本人智商太低，所以我上网查了查，总算明白是为什么了。

造成这结果的最大祸首是 1.1这个数字并不能精确的表示为一个double，往更大的范围说小数要用浮点数表示都是近似的，double是64bit，而float是32bit，按照IEEE745的规范，double要更精确些。我们知道计算机都是用二进制表示，那浮点数在计算机要怎么表示这就是按照刚才所说的规范，其中拿double来说，64位中，1位符号位，11位指数，还有52位尾数，在计算机中的顺序是从低位到高位。

从左到右是从低位到高位
如果我们需要将1.1化为二进制存在计算机中则可以采用乘2法，如下（整数部分为1，计算小数部分）

* 小数部分：0.1

* 0.1*2=0.2 取整数部分0， 基数=0.2   

* 0.2*2=0.4 取整数部分0， 基数=0.4

* 0.4*2=0.8 取整数部分0， 基数=0.8

* 0.8*2=1.6 取整数部分1， 基数=1.6-1=0.6

* 0.6*2=1.2 取整数部分1， 基数=1.2-1=0.2

* 0.2*2=0.4 取整数部分0， 基数=0.4

* ……

这样我们可以看到0.1在化为二进制的过程中，所取的部分会超过52bit，但是由于规范和计算机的限制，所以只能截取部分。我们知道计算机内的所有运算最后都会换算成加分，所以对于不精确的0.1表达，则会造成这样的后果，这并不是java的问题，是计算机和规范造成的。

##另一个实验
在这个实验是我在网上看到的,我把它翻译了下 [源地址](http://coding.derkeiler.com/Archive/Java/comp.lang.java.programmer/2007-01/msg00453.html)

```java
	public class Test
	{
		public static void
		main(String[] args)
		{
			System.out.println(0.1D);
			System.out.println(2.1D - 2.0D);
		}
	}               
```
输出结果为
0.1
0.10000000000000009

想想为什么会这样？
2.1用浮点数表示后，实际的值为
2.100000000000000088817841970012523233890533447265625

而2.0则表示为
2.

所以(2.1-2.0)的结果为
0.100000000000000088817841970012523233890533447265625

0.1D的真实表达值
0.1000000000000000055511151231257827021181583404541015625  

查查JAVA api，double转化为string是从一系列可以表达相同数值的浮点数中选折真实中最短的字符串/流

所以  0.10000000000000009  最接近  0.100000000000000088817841970012523233890533447265625

而  0.1 最接近 0.1000000000000000055511151231257827021181583404541015625

> 注: double的精确位为15，1位为近似位                                                             

另外推荐大家看 [浮点数的表示和基本运算](http://www.cnblogs.com/FlyingBread/archive/2009/02/15/660206.html)
